/*
github.ts

GitHub API 관련 유틸리티 함수
Blob, Tree, Commit 생성
Reference 관리
에러 처리 등
*/
import sha1 from 'sha1';
import { GitHubBlob, GitHubReference, GitHubTree, GitHubError, CommitData } from '@/types/github';

/**
 * GitHub blob SHA 계산
 */
export const calculateBlobSHA = (content: string): string => {
  return sha1(`blob ${new Blob([content]).size}\0${content}`);
};

/**
 * Base64로 문자열 인코딩
 */
export const b64EncodeUnicode = (str: string): string => {
  return btoa(
    encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (_, p1) => {
      return String.fromCharCode(parseInt(p1, 16));
    })
  );
};

/**
 * GitHub API 에러 처리
 */
export const handleGitHubError = (error: any): GitHubError => {
  if (error.response) {
    const { status, data } = error.response;
    return {
      status,
      message: data.message || 'Unknown GitHub API error',
    };
  }
  return {
    status: 500,
    message: error.message || 'Internal error occurred',
  };
};

/**
 * GitHub 클래스
 */
export class GitHub {
  private readonly baseUrl = 'https://api.github.com';
  private hook: string;
  private token: string;

  constructor(hook: string, token: string) {
    this.hook = hook;
    this.token = token;
  }

  /**
   * API 요청을 보내는 유틸리티 메서드
   */
  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = {
      Authorization: `token ${this.token}`,
      Accept: 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
      ...options.headers,
    };

    const response = await fetch(url, { ...options, headers });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'GitHub API request failed');
    }

    return response.json();
  }

  /**
   * 저장소의 기본 브랜치 가져오기
   */
  async getDefaultBranchOnRepo(): Promise<string> {
    const data = await this.request<{ default_branch: string }>(`/repos/${this.hook}`);
    return data.default_branch;
  }

  /**
   * 레퍼런스 가져오기
   */
  async getReference(branch = 'main'): Promise<GitHubReference> {
    const data = await this.request<{
      ref: string;
      object: { sha: string };
    }>(`/repos/${this.hook}/git/refs/heads/${branch}`);

    return {
      ref: data.ref,
      refSHA: data.object.sha,
    };
  }

  /**
   * Blob 생성하기
   */
  async createBlob(content: string, path: string): Promise<GitHubBlob> {
    const data = await this.request<{ sha: string }>(`/repos/${this.hook}/git/blobs`, {
      method: 'POST',
      body: JSON.stringify({
        content: b64EncodeUnicode(content),
        encoding: 'base64',
      }),
    });

    return {
      path,
      sha: data.sha,
      mode: '100644',
      type: 'blob',
    };
  }

  /**
   * 트리 생성하기
   */
  async createTree(baseTreeSHA: string, tree: GitHubBlob[]): Promise<string> {
    const data = await this.request<{ sha: string }>(`/repos/${this.hook}/git/trees`, {
      method: 'POST',
      body: JSON.stringify({
        base_tree: baseTreeSHA,
        tree,
      }),
    });

    return data.sha;
  }

  /**
   * 커밋 생성하기
   */
  async createCommit(message: string, treeSHA: string, parentSHA: string): Promise<string> {
    const data = await this.request<{ sha: string }>(`/repos/${this.hook}/git/commits`, {
      method: 'POST',
      body: JSON.stringify({
        message,
        tree: treeSHA,
        parents: [parentSHA],
      }),
    });

    return data.sha;
  }

  /**
   * 레퍼런스 업데이트하기
   */
  async updateHead(ref: string, commitSHA: string, force = true): Promise<string> {
    const data = await this.request<{ object: { sha: string } }>(`/repos/${this.hook}/git/${ref}`, {
      method: 'PATCH',
      body: JSON.stringify({
        sha: commitSHA,
        force,
      }),
    });

    return data.object.sha;
  }

  /**
   * 트리 가져오기
   */
  async getTree(): Promise<GitHubTree['tree']> {
    const data = await this.request<GitHubTree>(`/repos/${this.hook}/git/trees/HEAD?recursive=1`);
    return data.tree;
  }

  /**
   * 파일 업로드하기
   */
  async uploadFile(data: CommitData): Promise<string> {
    const branch = data.branch || 'main';
    const { refSHA, ref } = await this.getReference(branch);
    const blobSHA = await this.createBlob(data.content, '');
    const treeSHA = await this.createTree(refSHA, [blobSHA]);
    const commitSHA = await this.createCommit(data.message, treeSHA, refSHA);
    return this.updateHead(ref, commitSHA);
  }

  /**
   * 저장소 생성하기
   */
  async createRepository(name: string, isPrivate = true): Promise<void> {
    await this.request('/user/repos', {
      method: 'POST',
      body: JSON.stringify({
        name,
        private: isPrivate,
        auto_init: true,
        description: 'Auto-generated by BaekjoonHub',
      }),
    });
  }

  /**
   * 저장소 존재 여부 확인하기
   */
  async repositoryExists(owner: string, repo: string): Promise<boolean> {
    try {
      await this.request(`/repos/${owner}/${repo}`);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 파일 존재 여부 확인하기
   */
  async fileExists(path: string, branch = 'main'): Promise<boolean> {
    try {
      await this.request(`/repos/${this.hook}/contents/${path}?ref=${branch}`);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 저장소 포크하기
   */
  async forkRepository(owner: string, repo: string): Promise<void> {
    await this.request(`/repos/${owner}/${repo}/forks`, {
      method: 'POST',
    });
  }

  /**
   * Pull Request 생성하기
   */
  async createPullRequest(base: string, head: string, title: string, body: string): Promise<void> {
    await this.request(`/repos/${this.hook}/pulls`, {
      method: 'POST',
      body: JSON.stringify({
        title,
        body,
        head,
        base,
      }),
    });
  }
}
